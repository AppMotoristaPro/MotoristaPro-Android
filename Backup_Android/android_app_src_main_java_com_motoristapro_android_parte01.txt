
================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/ErrorActivity.kt
================================================================================
package com.motoristapro.android

import android.app.Activity
import android.os.Bundle
import android.widget.ScrollView
import android.widget.TextView
import android.graphics.Color
import android.widget.LinearLayout

class ErrorActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val scroll = ScrollView(this)
        val layout = LinearLayout(this)
        layout.orientation = LinearLayout.VERTICAL
        layout.setPadding(50, 50, 50, 50)
        layout.setBackgroundColor(Color.WHITE)

        val title = TextView(this)
        title.text = "ERRO FATAL (CRASH)"
        title.textSize = 24f
        title.setTextColor(Color.RED)
        title.setPadding(0, 0, 0, 30)

        val message = TextView(this)
        message.text = intent.getStringExtra("error") ?: "Erro desconhecido"
        message.textSize = 14f
        message.setTextColor(Color.BLACK)

        layout.addView(title)
        layout.addView(message)
        scroll.addView(layout)

        setContentView(scroll)
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/Logger.kt
================================================================================
package com.motoristapro.android

import android.util.Log

object Logger {
    // Em produ√ß√£o, usamos Logcat. 
    // O usu√°rio n√£o v√™, mas o desenvolvedor v√™ no Android Studio.
    
    fun log(tag: String, msg: String) {
        // Log.d = Debug. Use Log.i para Info ou Log.e para Erro.
        Log.d("MotoristaPro_$tag", msg)
    }

    fun clear() {
        // N√£o √© necess√°rio limpar Logcat programaticamente
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MainActivity.kt
================================================================================
package com.motoristapro.android

import android.view.accessibility.AccessibilityManager
import android.accessibilityservice.AccessibilityServiceInfo
import android.Manifest
import android.app.Dialog
import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.os.Message
import android.print.PrintAttributes
import android.print.PrintManager
import android.provider.Settings
import android.util.Base64
import android.view.LayoutInflater
import android.view.ViewGroup
import android.view.Window
import android.webkit.*
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import com.google.firebase.messaging.FirebaseMessaging
import java.io.File
import java.io.FileOutputStream

class MainActivity : ComponentActivity() {

    private lateinit var webView: WebView
    private val NOTIFICATION_PERMISSION_CODE = 101
    
    // Vari√°veis para Upload de Arquivo
    private var fileUploadCallback: ValueCallback<Array<Uri>>? = null
    private val FILE_CHOOSER_RESULT_CODE = 100

    private val jsReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val js = intent?.getStringExtra("js")
            if (js != null) {
                webView.evaluateJavascript(js, null)
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        webView = findViewById(R.id.webView)
        setupWebView(webView)

        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(jsReceiver, IntentFilter("wwebview.js_command"), Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(jsReceiver, IntentFilter("wwebview.js_command"))
        }

        handleIntent(intent)
        askNotificationPermission()
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        handleIntent(intent)
    }

    // Callback para receber o arquivo selecionado (Backup)
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        if (requestCode == FILE_CHOOSER_RESULT_CODE) {
            if (fileUploadCallback == null) return
            val results = WebChromeClient.FileChooserParams.parseResult(resultCode, data)
            fileUploadCallback?.onReceiveValue(results)
            fileUploadCallback = null
        } else {
            super.onActivityResult(requestCode, resultCode, data)
        }
    }

    private fun handleIntent(intent: Intent?) {
        if (intent?.action == "OPEN_ADD_SCREEN") {
            val h = intent.getIntExtra("h_val", 0)
            val m = intent.getIntExtra("m_val", 0)
            webView.loadUrl("https://motorista-pro-app.onrender.com/adicionar?tempo_cronometro=$h:$m")
        } else if (webView.url == null) {
            webView.loadUrl("https://motorista-pro-app.onrender.com")
        }
    }

    private fun setupWebView(view: WebView) {
        val settings = view.settings
        settings.javaScriptEnabled = true
        settings.domStorageEnabled = true
        settings.javaScriptCanOpenWindowsAutomatically = true
        settings.setSupportMultipleWindows(true)
        settings.allowFileAccess = true
        settings.allowContentAccess = true
        
        val defaultUA = settings.userAgentString
        settings.userAgentString = defaultUA.replace("; wv", "") + " (MotoristaPro)"

        if (view == webView) {
            view.addJavascriptInterface(WebAppInterface(this), "MotoristaProAndroid")
        }

        // Configura√ß√£o de Downloads
        view.setDownloadListener { url, userAgent, contentDisposition, mimetype, contentLength ->
            try {
                val request = DownloadManager.Request(Uri.parse(url))
                request.setMimeType(mimetype)
                request.addRequestHeader("User-Agent", userAgent)
                request.setDescription("Baixando arquivo...")
                val fileName = URLUtil.guessFileName(url, contentDisposition, mimetype)
                request.setTitle(fileName)
                request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
                request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName)
                
                val dm = getSystemService(DOWNLOAD_SERVICE) as DownloadManager
                dm.enqueue(request)
                Toast.makeText(applicationContext, "Download iniciado...", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Toast.makeText(applicationContext, "Erro ao baixar: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }

        view.webViewClient = object : WebViewClient() {
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)
                val jsPrint = "window.print = function() { MotoristaProAndroid.printPage(); };"
                view?.evaluateJavascript(jsPrint, null)
            }

            // CORRE√á√ÉO WHATSAPP: Intercepta links externos
            override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
                val url = request?.url?.toString() ?: return false
                
                // Se for http/https normal, deixa o WebView carregar
                if (url.startsWith("http://") || url.startsWith("https://")) {
                    // Exce√ß√£o: Links do WhatsApp Web que redirecionam para app
                    if (url.contains("wa.me") || url.contains("api.whatsapp.com")) {
                        return false // Deixa carregar e o site redireciona para scheme whatsapp://
                    }
                    return false 
                }

                // Se for esquema customizado (whatsapp://, tel:, mailto:, intent://)
                try {
                    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
                    startActivity(intent)
                    return true // N√≥s tratamos, WebView n√£o precisa fazer nada
                } catch (e: Exception) {
                    // App n√£o instalado (ex: WhatsApp n√£o instalado)
                    return true 
                }
            }
        }

        view.webChromeClient = object : WebChromeClient() {
            // CORRE√á√ÉO UPLOAD: Abre seletor de arquivos nativo
            override fun onShowFileChooser(webView: WebView?, filePathCallback: ValueCallback<Array<Uri>>?, fileChooserParams: FileChooserParams?): Boolean {
                if (fileUploadCallback != null) {
                    fileUploadCallback?.onReceiveValue(null)
                    fileUploadCallback = null
                }
                fileUploadCallback = filePathCallback

                val intent = fileChooserParams?.createIntent()
                if (intent != null) {
                    try {
                        startActivityForResult(intent, FILE_CHOOSER_RESULT_CODE)
                    } catch (e: Exception) {
                        fileUploadCallback = null
                        return false
                    }
                } else {
                    fileUploadCallback = null
                    return false
                }
                return true
            }

            override fun onCreateWindow(view: WebView?, isDialog: Boolean, isUserGesture: Boolean, resultMsg: Message?): Boolean {
                val newWebView = WebView(this@MainActivity)
                setupWebView(newWebView) // Aplica as mesmas regras (WhatsApp, Uploads) para popups
                val dialog = Dialog(this@MainActivity, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
                dialog.setContentView(newWebView)
                dialog.show()
                newWebView.webChromeClient = object : WebChromeClient() {
                    override fun onCloseWindow(window: WebView?) { dialog.dismiss() }
                }
                val transport = resultMsg?.obj as WebView.WebViewTransport
                transport.webView = newWebView
                resultMsg.sendToTarget()
                return true
            }
        }
    }

    private fun askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= 33) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), NOTIFICATION_PERMISSION_CODE)
            }
        }
    }

    inner class WebAppInterface(private val context: Context) {
        @JavascriptInterface
        fun startRobot() { runOnUiThread { checkAndRequestPermissions() } }

        @JavascriptInterface
        fun requestPermission() { runOnUiThread { checkAndRequestPermissions() } }

        @JavascriptInterface
        fun subscribeToPush(userId: String) {
            FirebaseMessaging.getInstance().subscribeToTopic("all_users")
            if (userId.isNotEmpty()) FirebaseMessaging.getInstance().subscribeToTopic("user_$userId")
        }

        @JavascriptInterface
        fun syncTimer(state: String, startTs: Long, elapsed: Long) {
            val intent = Intent(context, TimerService::class.java)
            intent.action = TimerService.ACTION_SYNC
            intent.putExtra("state", state)
            intent.putExtra("start_ts", startTs)
            intent.putExtra("elapsed", elapsed)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(intent)
            } else {
                context.startService(intent)
            }
        }

        @JavascriptInterface
        fun printPage() {
            runOnUiThread {
                val printManager = getSystemService(Context.PRINT_SERVICE) as? PrintManager
                val adapter = webView.createPrintDocumentAdapter("MotoristaPro_Doc")
                printManager?.print("Documento_MotoristaPro", adapter, PrintAttributes.Builder().build())
            }
        }

        @JavascriptInterface
        fun shareBase64Image(base64Data: String, title: String) {
            runOnUiThread {
                try {
                    val cleanBase64 = if (base64Data.contains(",")) base64Data.split(",")[1] else base64Data
                    val decodedString = Base64.decode(cleanBase64, Base64.DEFAULT)
                    
                    val cachePath = File(context.cacheDir, "images")
                    cachePath.mkdirs()
                    val stream = FileOutputStream("$cachePath/recibo.png")
                    stream.write(decodedString)
                    stream.close()

                    val newFile = File(cachePath, "recibo.png")
                    val contentUri = FileProvider.getUriForFile(context, "$packageName.provider", newFile)

                    if (contentUri != null) {
                        val shareIntent = Intent()
                        shareIntent.action = Intent.ACTION_SEND
                        shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        shareIntent.setDataAndType(contentUri, context.contentResolver.getType(contentUri))
                        shareIntent.putExtra(Intent.EXTRA_STREAM, contentUri)
                        shareIntent.type = "image/png"
                        startActivity(Intent.createChooser(shareIntent, title))
                    }
                } catch (e: Exception) {
                    Toast.makeText(context, "Erro: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun checkAndRequestPermissions() {
        if (!Settings.canDrawOverlays(this)) {
            showProfessionalDialog(
                title = "Permiss√£o de Sobreposi√ß√£o",
                message = "O Motorista Pro precisa exibir informa√ß√µes sobrepostas.",
                iconRes = R.drawable.ic_permission_layers,
                isAccessibility = false
            ) {
                startActivity(Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName")))
            }
            return
        }

        if (!isAccessibilityServiceEnabled()) {
            showProfessionalDialog(
                title = "Servi√ßo de Acessibilidade",
                message = "Necess√°rio para leitura de tela.",
                iconRes = R.drawable.ic_permission_eye,
                isAccessibility = true
            ) {
                startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))
            }
            return
        }

        startOcrService()
    }

    private fun showProfessionalDialog(title: String, message: String, iconRes: Int, isAccessibility: Boolean, positiveAction: () -> Unit) {
        val dialog = Dialog(this)
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE)
        val view = LayoutInflater.from(this).inflate(R.layout.dialog_permission_edu, null)
        dialog.setContentView(view)
        dialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        dialog.setCancelable(false)

        view.findViewById<TextView>(R.id.dialog_title).text = title
        view.findViewById<TextView>(R.id.dialog_message).text = message
        view.findViewById<ImageView>(R.id.dialog_icon).setImageResource(iconRes)

        view.findViewById<Button>(R.id.btn_allow).setOnClickListener {
            dialog.dismiss()
            if (isAccessibility) Toast.makeText(this, "Toque em 'Aplicativos instalados' > 'Motorista Pro'", Toast.LENGTH_LONG).show()
            positiveAction()
        }
        view.findViewById<TextView>(R.id.btn_cancel).setOnClickListener { dialog.dismiss() }
        dialog.show()
        dialog.window?.setLayout((resources.displayMetrics.widthPixels * 0.90).toInt(), ViewGroup.LayoutParams.WRAP_CONTENT)
    }

    private fun startOcrService() {
        try {
            val intent = Intent(this, OcrService::class.java)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent) else startService(intent)
            Toast.makeText(this, "Rob√¥ Iniciado!", Toast.LENGTH_LONG).show()
        } catch (e: Exception) { Toast.makeText(this, "Erro: ${e.message}", Toast.LENGTH_SHORT).show() }
    }

    private fun isAccessibilityServiceEnabled(): Boolean {
        val am = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
        val enabledServices = am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_GENERIC)
        for (service in enabledServices) {
            if (service.resolveInfo.serviceInfo.packageName == packageName &&
                service.resolveInfo.serviceInfo.name.endsWith("WindowMonitorService")) return true
        }
        return false
    }

    override fun onDestroy() {
        super.onDestroy()
        try { unregisterReceiver(jsReceiver) } catch (e: Exception) {}
    }

    override fun onBackPressed() { if (webView.canGoBack()) webView.goBack() else super.onBackPressed() }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MotoristaApp.kt
================================================================================
package com.motoristapro.android

import android.app.Application
import android.content.Intent
import android.os.Process
import java.io.PrintWriter
import java.io.StringWriter

class MotoristaApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Define o capturador padr√£o de exce√ß√µes n√£o tratadas
        Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->
            handleUncaughtException(thread, throwable)
        }
    }

    private fun handleUncaughtException(thread: Thread, e: Throwable) {
        e.printStackTrace() // Loga no console se poss√≠vel

        val sw = StringWriter()
        e.printStackTrace(PrintWriter(sw))
        val stackTrace = sw.toString()

        // Abre uma Activity de Erro para mostrar o texto na tela
        val intent = Intent(applicationContext, ErrorActivity::class.java)
        intent.putExtra("error", stackTrace)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
        startActivity(intent)

        Process.killProcess(Process.myPid())
        System.exit(1)
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MyFirebaseMessagingService.kt
================================================================================
package com.motoristapro.android

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage

class MyFirebaseMessagingService : FirebaseMessagingService() {

    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        // Verifica se a mensagem tem payload de notifica√ß√£o
        remoteMessage.notification?.let {
            sendNotification(it.title ?: "Nova Mensagem", it.body ?: "")
        }
    }

    private fun sendNotification(title: String, messageBody: String) {
        val intent = Intent(this, MainActivity::class.java)
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
        
        val pendingIntent = PendingIntent.getActivity(
            this, 0, intent,
            PendingIntent.FLAG_ONE_SHOT or PendingIntent.FLAG_IMMUTABLE
        )

        val channelId = "motorista_pro_channel"
        val notificationBuilder = NotificationCompat.Builder(this, channelId)
            .setSmallIcon(R.mipmap.ic_launcher) // √çcone padr√£o do app
            .setContentTitle(title)
            .setContentText(messageBody)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_HIGH)

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        // Cria o canal de notifica√ß√£o (Necess√°rio para Android 8.0+)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                "Avisos Motorista Pro",
                NotificationManager.IMPORTANCE_HIGH
            )
            notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(System.currentTimeMillis().toInt(), notificationBuilder.build())
    }
}

================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/OcrService.kt
================================================================================
package com.motoristapro.android

import android.app.Service
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.ServiceInfo
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.graphics.Color
import android.graphics.Outline
import android.graphics.PixelFormat
import android.graphics.Typeface
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Environment
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.ViewOutlineProvider
import android.view.WindowManager
import android.widget.Button
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.core.app.NotificationCompat
import org.json.JSONArray
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.regex.Pattern
import kotlin.math.abs

class OcrService : Service() {

    private lateinit var windowManager: WindowManager
    private val autoHideHandler = Handler(Looper.getMainLooper())
    private val autoHideRunnable = Runnable { hideCard() }
    
    private val AUTO_HIDE_DELAY = 7000L 

    private var bubbleView: View? = null
    private var menuView: View? = null
    private var settingsView: View? = null
    private var infoCardView: LinearLayout? = null
    private var iconView: ImageView? = null
    
    private var tvMenuPauseTitle: TextView? = null
    private var tvMenuPauseIcon: TextView? = null
    
    private lateinit var tvAppBadge: TextView
    private lateinit var tvValorTopo: TextView
    private lateinit var tvDadosMeio: TextView
    private lateinit var tvResultadosBaixo: TextView
    private lateinit var tvDicaAcao: TextView
    
    private lateinit var etGoodKm: EditText
    private lateinit var etBadKm: EditText
    private lateinit var etGoodHour: EditText
    private lateinit var etBadHour: EditText

    private var goodKm: Double = 2.0
    private var badKm: Double = 1.5
    private var goodHour: Double = 60.0
    private var badHour: Double = 40.0
    
    private var isMonitoring: Boolean = true
    private var isMenuOpen: Boolean = false
    private var isSettingsOpen: Boolean = false
    
    private lateinit var bubbleParams: WindowManager.LayoutParams
    private lateinit var menuParams: WindowManager.LayoutParams
    private lateinit var settingsParams: WindowManager.LayoutParams
    private lateinit var cardParams: WindowManager.LayoutParams

    // --- NOVO: CONTROLE DE DUPLICIDADE ---
    // Armazena os dados da √∫ltima leitura v√°lida
    data class RideData(val price: Double, val dist: Double, val time: Double)
    private var lastRideData: RideData? = null
    // -------------------------------------

    private val hideCardReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (infoCardView?.visibility == View.VISIBLE) {
                infoCardView?.visibility = View.GONE
                bubbleView?.visibility = View.GONE 
            }
            // Reseta a √∫ltima leitura ao esconder
            lastRideData = null
        }
    }
    
    private val textReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val jsonData = intent?.getStringExtra("JSON_DATA")
            val pkg = intent?.getStringExtra("APP_PACKAGE") ?: ""
            val screenH = intent?.getIntExtra("SCREEN_HEIGHT", 2000) ?: 2000
            
            if (!jsonData.isNullOrEmpty()) {
                analyzeSmartData(jsonData, pkg, screenH)
            }
        }
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onCreate() {
        super.onCreate()
        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        loadConfigs()
        Logger.log("LIFECYCLE", "OcrService Iniciado.")
        
        // --- CORRE√á√ÉO ANDROID 14 (API 34) ---
        // O Android 14 exige flag EXPORTED/NOT_EXPORTED para receivers din√¢micos
        
        val filterText = IntentFilter("ACTION_PROCESS_TEXT")
        val filterHide = IntentFilter("com.motoristapro.ACTION_HIDE_CARD")

        if (Build.VERSION.SDK_INT >= 33) {
            // Context.RECEIVER_EXPORTED √© exigido para receivers que recebem broadcasts do sistema ou de outros apps
            // Como usamos broadcasts personalizados, precisamos definir
            registerReceiver(textReceiver, filterText, Context.RECEIVER_EXPORTED)
            registerReceiver(hideCardReceiver, filterHide, Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(textReceiver, filterText)
            registerReceiver(hideCardReceiver, filterHide)
        }
        
        try {
            startForegroundServiceCompat()
            createBubble()
            createMenu()
            createSettingsView()
            createInfoCard()
            saveLog("--- ROB√î INICIADO ---")
        } catch (e: Exception) { e.printStackTrace() }
    }

    private fun saveLog(msg: String) { 
        try { android.util.Log.i("MotoristaPro_OCR", msg) } catch (e: Exception) {} 
    }

    private fun startForegroundServiceCompat() {
        val channelId = "ocr_service_channel"
        val channel = NotificationChannel(channelId, "Motorista Pro", NotificationManager.IMPORTANCE_LOW)
        getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        val stopIntent = Intent(this, OcrService::class.java).apply { action = "STOP_SERVICE" }
        val stopPendingIntent = PendingIntent.getService(this, 0, stopIntent, PendingIntent.FLAG_IMMUTABLE)
        val notification = NotificationCompat.Builder(this, channelId)
            .setContentTitle("Motorista Pro")
            .setSmallIcon(R.mipmap.ic_launcher)
            .addAction(android.R.drawable.ic_menu_close_clear_cancel, "Parar", stopPendingIntent)
            .setOngoing(true)
            .build()
        if (Build.VERSION.SDK_INT >= 34) {
            startForeground(1, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            startForeground(1, notification)
        }
    }

    private fun sanitizeOcrErrors(input: String): String {
        var text = input.lowercase().replace("\n", " ").replace(",", ".")
        text = text.replace(Regex("m[1i]nut[o0]5?"), "min")
                   .replace(Regex("m[1i]n"), "min")
        if (text.contains("km") || text.contains("min") || text.contains("m ") || text.contains("h")) {
            text = text.replace("o", "0")
                       .replace("l", "1")
                       .replace("i", "1")
                       .replace("s", "5")
                       .replace("b", "8")
        }
        return text
    }

    private fun analyzeSmartData(jsonString: String, pkgName: String, screenHeight: Int) {
        Logger.log("ENGINE", "Iniciando an√°lise de dados OCR...")
        try {
            if (!isMonitoring) return

            val blocks = JSONArray(jsonString)
            var bestPrice = 0.0
            var maxPriceFontSize = 0
            var totalDist = 0.0
            var totalTime = 0.0
            
            val detectedApp = if (pkgName.contains("taxis99") || pkgName.contains("didi") || pkgName.contains("99")) "99" else "UBER"
            val ignoreTopLimit = screenHeight * 0.10

            for (i in 0 until blocks.length()) {
                val obj = blocks.getJSONObject(i)
                val rawText = obj.getString("text")
                val h = obj.getInt("h")
                val y = obj.getInt("y")
                
                if (y < ignoreTopLimit) continue

                val cleanText = sanitizeOcrErrors(rawText)

                if (cleanText.contains("ganhe r$") || cleanText.contains("a mais por") || cleanText.contains("viagens e ganhe") || cleanText.contains("meta de ganhos")) continue
                if (cleanText.contains("r$/km") || cleanText.contains("r$/h") || cleanText.contains("5h0wr00m") || cleanText.contains("showroom")) continue
                if (cleanText.contains("ma15 de 30") || cleanText.contains("mais de 30") || cleanText.contains("ma1s de 30")) continue
                if (cleanText.contains("mapa de chamada") || cleanText.contains("chamadas") || cleanText == "30 m") continue
                
                // A. PRE√áO - FIX REGEX STRING ESCAPES
                val matPrice = Pattern.compile("(?:r\\$|rs)\\s*([0-9]+(?:\\.[0-9]{2})?)").matcher(cleanText)
                if (matPrice.find()) {
                    val v = matPrice.group(1)?.toDoubleOrNull() ?: 0.0
                    if (v > 4.5) {
                        if (h > maxPriceFontSize) {
                            maxPriceFontSize = h; bestPrice = v
                        } else if (h == maxPriceFontSize && v > bestPrice) {
                            bestPrice = v
                        }
                    }
                }
                if (bestPrice == 0.0 && h > 80) {
                     // FIX REGEX
                     val matPrice2 = Pattern.compile("^([0-9]+(?:\\.[0-9]{2}))$").matcher(cleanText.trim())
                     if (matPrice2.find()) {
                         val v = matPrice2.group(1)?.toDoubleOrNull() ?: 0.0
                         if (v > 5.0 && v < 500.0) { bestPrice = v; maxPriceFontSize = h }
                     }
                }

                // B. DIST√ÇNCIA - FIX REGEX
                val matDist = Pattern.compile("\\(?([0-9]+(?:\\.[0-9]+)?)\\s*(km|m)\\)?").matcher(cleanText)
                while (matDist.find()) {
                    val valStr = matDist.group(1) ?: "0"
                    val unit = matDist.group(2) ?: "km"
                    var value = valStr.toDoubleOrNull() ?: 0.0
                    if (unit == "m") value /= 1000.0
                    if (value > 0.1 && value < 300.0) { totalDist += value }
                }

                // C. TEMPO - FIX REGEX
                var textForTime = cleanText.replace(Regex("\\d{1,2}:\\d{2}"), " ")
                val matHour = Pattern.compile("(\\d+)\\s*(?:h|hr|hrs|hora|horas)\\b")
                val mHour = matHour.matcher(textForTime)
                while (mHour.find()) {
                    val hVal = mHour.group(1)?.toDoubleOrNull() ?: 0.0
                    if (hVal > 0 && hVal < 24) { totalTime += (hVal * 60) }
                }
                val matMin = Pattern.compile("(\\d+)\\s*(?:min|minutos|m1n|m1ns|mins)(?!in|etro|l|e|a|o)")
                val mMin = matMin.matcher(textForTime)
                while (mMin.find()) {
                    val mVal = mMin.group(1)?.toDoubleOrNull() ?: 0.0
                    if (mVal > 0 && mVal < 600) { totalTime += mVal }
                }
            }

            // D. VALIDA√á√ÉO E ANTI-DUPLICIDADE
            val isValidReading = (bestPrice > 0.0) && ((totalDist > 0.0) || (totalTime > 0.0))
            
            if (isValidReading) {
                // --- NOVA L√ìGICA: Verifica se √© a mesma leitura anterior ---
                val currentReading = RideData(bestPrice, totalDist, totalTime)
                
                if (lastRideData != null) {
                    if (lastRideData == currentReading) {
                        Logger.log("FILTER", "Leitura duplicada ignorada: R$$bestPrice")
                        return // <--- SAI AQUI SE FOR IGUAL
                    }
                }
                
                // Se for diferente, atualiza o √∫ltimo e exibe
                lastRideData = currentReading
                // -----------------------------------------------------------

                val safeDist = if (totalDist == 0.0) 0.1 else totalDist
                val safeTime = if (totalTime == 0.0) 1.0 else totalTime 

                val valPerKm = bestPrice / safeDist
                val valPerHour = (bestPrice / safeTime) * 60.0
                
                val resultStyle = if (valPerKm >= goodKm && valPerHour >= goodHour) {
                    Triple(Color.parseColor("#4ADE80"), "√ìTIMA üöÄ", "#334ADE80")
                } else if (valPerKm <= badKm && valPerHour <= badHour) {
                    Triple(Color.parseColor("#F87171"), "RECUSAR üõë", "#33F87171")
                } else {
                    Triple(Color.parseColor("#FACC15"), "ANALISAR ü§î", "#33FACC15")
                }
                
                val (finalColor, finalMsg, finalAlpha) = resultStyle
                val bgDica = GradientDrawable().apply { cornerRadius = 15f; setColor(Color.parseColor(finalAlpha)) }
                
                showCard(bestPrice, totalDist, totalTime, valPerKm, valPerHour, finalColor, finalMsg, bgDica, detectedApp)
            }

        } catch (e: Exception) { e.printStackTrace() }
    }

    private fun showCard(price: Double, dist: Double, time: Double, valKm: Double, valHora: Double, color: Int, msg: String, bgDica: Drawable, detectedApp: String) {
        Handler(Looper.getMainLooper()).post {
            autoHideHandler.removeCallbacks(autoHideRunnable)
            
            bubbleView?.visibility = View.GONE
            infoCardView?.visibility = View.VISIBLE
            
            val badgeBg = GradientDrawable().apply { cornerRadius = 10f }

            if (detectedApp == "UBER") {
                tvAppBadge.visibility = View.VISIBLE; tvAppBadge.text = "UBER"; tvAppBadge.setTextColor(Color.WHITE); badgeBg.setColor(Color.BLACK)
            } else if (detectedApp == "99") {
                tvAppBadge.visibility = View.VISIBLE; tvAppBadge.text = "99"; tvAppBadge.setTextColor(Color.BLACK); badgeBg.setColor(Color.parseColor("#F7C948"))
            } else {
                tvAppBadge.visibility = View.GONE
            }

            tvAppBadge.background = badgeBg
            tvValorTopo.text = String.format("R$ %.2f", price)
            tvValorTopo.setTextColor(color) 
            
            tvDadosMeio.text = String.format("%.1f km ‚Ä¢ %.0f min", dist, time)
            tvResultadosBaixo.text = String.format("R$ %.2f/km ‚Ä¢ R$ %.0f/h", valKm, valHora)
            tvResultadosBaixo.setTextColor(color)
            tvDicaAcao.text = msg
            tvDicaAcao.setTextColor(color)
            tvDicaAcao.background = bgDica
            
            autoHideHandler.postDelayed(autoHideRunnable, AUTO_HIDE_DELAY)
        }
    }
    
    private fun hideCard() { 
        Handler(Looper.getMainLooper()).post { 
            autoHideHandler.removeCallbacks(autoHideRunnable)
            infoCardView?.visibility = View.GONE
            if (isMonitoring) bubbleView?.visibility = View.VISIBLE 
            // Reseta a duplicidade ap√≥s timeout para permitir ler de novo se necess√°rio
            lastRideData = null 
        } 
    }
    
    private fun createInfoCard() {
        val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
        val savedX = prefs.getInt("card_x", 0)
        val savedY = prefs.getInt("card_y", 100)
        infoCardView = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(30, 25, 30, 25); visibility = View.GONE; background = GradientDrawable().apply { cornerRadius = 40f; setColor(Color.parseColor("#E6334155")); setStroke(2, Color.parseColor("#33FFFFFF")) } }
        tvAppBadge = TextView(this).apply { text="APP"; setTextColor(Color.WHITE); gravity=Gravity.CENTER; textSize=10f; typeface=Typeface.DEFAULT_BOLD; setPadding(20,5,20,5); layoutParams=LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { gravity=Gravity.CENTER_HORIZONTAL; bottomMargin=10 } }
        tvValorTopo = TextView(this).apply { text="--"; textSize=26f; setTextColor(Color.WHITE); typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER }
        tvDadosMeio = TextView(this).apply { text="--"; textSize=14f; setTextColor(Color.LTGRAY); gravity=Gravity.CENTER }
        tvResultadosBaixo = TextView(this).apply { text="--"; textSize=18f; typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER }
        tvDicaAcao = TextView(this).apply { text="..."; textSize=14f; typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER; setPadding(10,5,10,5) }
        infoCardView!!.addView(tvAppBadge); infoCardView!!.addView(tvValorTopo); infoCardView!!.addView(tvDadosMeio); infoCardView!!.addView(tvResultadosBaixo); infoCardView!!.addView(tvDicaAcao)
        cardParams = WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START; x = savedX; y = savedY; width = (resources.displayMetrics.widthPixels * 0.65).toInt() }
        
        infoCardView!!.setOnTouchListener(object : View.OnTouchListener {
            private var iX=0; private var iY=0; private var iTX=0f; private var iTY=0f; private var isDrag=false
            override fun onTouch(v: View?, event: MotionEvent?): Boolean {
                if (event == null) return false
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> { iX = cardParams.x; iY = cardParams.y; iTX = event.rawX; iTY = event.rawY; isDrag = false; return true }
                    MotionEvent.ACTION_MOVE -> { val dx = (event.rawX - iTX).toInt(); val dy = (event.rawY - iTY).toInt(); if (abs(dx) > 10 || abs(dy) > 10) { isDrag = true; cardParams.x = iX + dx; cardParams.y = iY + dy; windowManager.updateViewLayout(infoCardView, cardParams) }; return true }
                    MotionEvent.ACTION_UP -> { if (isDrag) { prefs.edit().putInt("card_x", cardParams.x).putInt("card_y", cardParams.y).apply() } else { hideCard() }; return true }
                }
                return false
            }
        })
        windowManager.addView(infoCardView, cardParams)
    }

    private fun toggleMonitoring() { isMonitoring = !isMonitoring; iconView?.alpha = if(isMonitoring) 1f else 0.5f; if(!isMonitoring) hideCard(); Toast.makeText(this, if(isMonitoring) "Ativo" else "Pausado", Toast.LENGTH_SHORT).show() }
    private fun toggleMenu() { if(isMenuOpen) closeMenu() else openMenu() }
    private fun openSettings() { isSettingsOpen = true; settingsView!!.visibility = View.VISIBLE; windowManager.updateViewLayout(settingsView, settingsParams) }
    private fun closeSettings() { isSettingsOpen = false; settingsView!!.visibility = View.GONE }
    private fun openMenu() { 
        isMenuOpen = true; menuParams.x = bubbleParams.x; menuParams.y = bubbleParams.y + bubbleView!!.height + 15
        if (isMonitoring) { tvMenuPauseTitle?.text = "Pausar Leitura"; tvMenuPauseIcon?.text = "‚è∏" } else { tvMenuPauseTitle?.text = "Retomar Leitura"; tvMenuPauseIcon?.text = "‚ñ∂Ô∏è" }
        menuView!!.visibility = View.VISIBLE; windowManager.updateViewLayout(menuView, menuParams); Handler(Looper.getMainLooper()).postDelayed({ if (isMenuOpen) closeMenu() }, 5000) 
    }
    private fun closeMenu() { isMenuOpen = false; menuView!!.visibility = View.GONE }
    private fun openApp(target: String) { try { val i = packageManager.getLaunchIntentForPackage(packageName); i?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); closeMenu() } catch (e: Exception) { Toast.makeText(this, "Erro", Toast.LENGTH_SHORT).show() } }

    private fun createBubble() {
        val bubbleLayout = FrameLayout(this)
        iconView = ImageView(this).apply { setImageResource(R.mipmap.ic_launcher_round); scaleType = ImageView.ScaleType.CENTER_CROP; clipToOutline = true; outlineProvider = object : ViewOutlineProvider() { override fun getOutline(view: View, outline: Outline) { outline.setOval(0, 0, view.width, view.height) } }; elevation = 20f }
        bubbleLayout.addView(iconView, FrameLayout.LayoutParams(150, 150))
        bubbleLayout.setOnTouchListener(object : View.OnTouchListener {
            private var iX=0; private var iY=0; private var iTX=0f; private var iTY=0f; private var drag=false
            override fun onTouch(v: View?, e: MotionEvent?): Boolean {
                when(e!!.action) {
                    MotionEvent.ACTION_DOWN->{iX=bubbleParams.x;iY=bubbleParams.y;iTX=e.rawX;iTY=e.rawY;drag=false;return true}
                    MotionEvent.ACTION_MOVE->{val dx=(e.rawX-iTX).toInt();val dy=(e.rawY-iTY).toInt();if(abs(dx)>10||abs(dy)>10){drag=true;bubbleParams.x=iX+dx;bubbleParams.y=iY+dy;windowManager.updateViewLayout(bubbleView,bubbleParams);if(isMenuOpen)closeMenu()};return true}
                    MotionEvent.ACTION_UP->{if(!drag)toggleMenu();return true}
                }
                return false
            }
        })
        bubbleView = bubbleLayout
        bubbleParams = WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START; x = 20; y = 300 }
        windowManager.addView(bubbleView, bubbleParams)
    }

    private fun createMenu() {
        val layout = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(0, 20, 0, 20); background = GradientDrawable().apply { setColor(Color.WHITE); cornerRadius = 30f; setStroke(1, Color.parseColor("#E2E8F0")) }; elevation = 40f }
        layout.addView(TextView(this).apply { text = "MOTORISTA PRO"; textSize = 12f; setTextColor(Color.parseColor("#64748B")); typeface = Typeface.DEFAULT_BOLD; gravity = Gravity.CENTER; setPadding(0, 10, 0, 25) })
        layout.addView(View(this).apply { layoutParams = LinearLayout.LayoutParams(-1, 2); setBackgroundColor(Color.parseColor("#F1F5F9")) })
        val btnPause = createMenuItem("‚èØ", "Pausar Leitura", Color.parseColor("#0F172A")) { toggleMonitoring(); closeMenu() }
        tvMenuPauseIcon = btnPause.getChildAt(0) as TextView; tvMenuPauseTitle = btnPause.getChildAt(1) as TextView; layout.addView(btnPause)
        layout.addView(createMenuItem("‚öôÔ∏è", "Configura√ß√µes", Color.parseColor("#0F172A")) { closeMenu(); openSettings() })
        layout.addView(createMenuItem("üì±", "Abrir Aplicativo", Color.parseColor("#2563EB")) { openApp("home"); closeMenu() })
        layout.addView(View(this).apply { layoutParams = LinearLayout.LayoutParams(-1, 2).apply { setMargins(40, 15, 40, 15) }; setBackgroundColor(Color.parseColor("#F1F5F9")) })
        layout.addView(createMenuItem("‚ùå", "Encerrar Tudo", Color.parseColor("#EF4444")) { stopSelf() })
        menuView = layout
        menuParams = WindowManager.LayoutParams(600, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START }
        menuView!!.visibility = View.GONE
        windowManager.addView(menuView, menuParams)
    }
    
    private fun createMenuItem(icon: String, text: String, textColor: Int, onClick: () -> Unit): LinearLayout {
        val container = LinearLayout(this).apply { orientation = LinearLayout.HORIZONTAL; gravity = Gravity.CENTER_VERTICAL; setPadding(50, 35, 50, 35); isClickable = true; setBackgroundColor(Color.TRANSPARENT); setOnClickListener { onClick() } }
        val tvIcon = TextView(this).apply { this.text = icon; textSize = 20f; setPadding(0, 0, 40, 0); setTextColor(textColor) }
        val tvText = TextView(this).apply { this.text = text; textSize = 15f; setTextColor(textColor); typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL) }
        container.addView(tvIcon); container.addView(tvText)
        return container
    }

    private fun createSettingsView() {
        val layout = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(50, 50, 50, 50); background = GradientDrawable().apply { setColor(Color.WHITE); cornerRadius = 45f } }
        val txtExpl = TextView(this).apply { text="COMO FUNCIONA A L√ìGICA DE CORES:\n\nüü¢ VERDE: Se (R$/KM >= Meta) E (R$/H >= Meta)\nüî¥ VERMELHO: Se (R$/KM <= Ruim) E (R$/H <= Ruim)\nüü° AMARELO: Qualquer outra combina√ß√£o mista."; textSize=12f; setTextColor(Color.parseColor("#64748B")); setPadding(0,0,0,30) }
        layout.addView(txtExpl)
        fun mkInp(t: String, v: Double): EditText { val et = EditText(this).apply { setText(v.toString()); inputType = 8194; setTextColor(Color.BLACK) }; layout.addView(TextView(this).apply { text = t; setTextColor(Color.GRAY) }); layout.addView(et); return et }
        etGoodKm = mkInp("KM Bom", goodKm); etBadKm = mkInp("KM Ruim", badKm); etGoodHour = mkInp("Hora Boa", goodHour); etBadHour = mkInp("Hora Ruim", badHour)
        val btnSave = Button(this).apply { text = "SALVAR"; setOnClickListener { saveConfigsLocally() } }; layout.addView(btnSave)
        settingsView = layout
        settingsParams = WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_DIM_BEHIND, PixelFormat.TRANSLUCENT).apply { dimAmount = 0.5f; gravity = Gravity.CENTER }
        settingsView!!.visibility = View.GONE
        windowManager.addView(settingsView, settingsParams)
    }

    private fun saveConfigsLocally() {
        try {
            val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
            goodKm = etGoodKm.text.toString().toDoubleOrNull() ?: 2.0; badKm = etBadKm.text.toString().toDoubleOrNull() ?: 1.5; goodHour = etGoodHour.text.toString().toDoubleOrNull() ?: 60.0; badHour = etBadHour.text.toString().toDoubleOrNull() ?: 40.0
            prefs.edit().putFloat("good_km", goodKm.toFloat()).putFloat("bad_km", badKm.toFloat()).putFloat("good_hour", goodHour.toFloat()).putFloat("bad_hour", badHour.toFloat()).apply()
            closeSettings(); Toast.makeText(this, "Salvo", Toast.LENGTH_SHORT).show()
        } catch (e: Exception) {}
    }
    
    private fun loadConfigs() {
        Logger.log("LIFECYCLE", "OcrService Iniciado. Configs carregadas: KM Bom=$goodKm, Hora Boa=$goodHour")
        val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
        goodKm = prefs.getFloat("good_km", 2.0f).toDouble(); badKm = prefs.getFloat("bad_km", 1.5f).toDouble(); goodHour = prefs.getFloat("good_hour", 60.0f).toDouble(); badHour = prefs.getFloat("bad_hour", 40.0f).toDouble()
    }

    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(textReceiver)
        try { 
            if (bubbleView != null) windowManager.removeView(bubbleView)
            if (menuView != null) windowManager.removeView(menuView)
            if (settingsView != null) windowManager.removeView(settingsView)
            if (infoCardView != null) windowManager.removeView(infoCardView)
        } catch (e: Exception) {}
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/TimerService.kt
================================================================================
package com.motoristapro.android

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.content.pm.ServiceInfo
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import java.util.Locale

class TimerService : Service() {

    companion object {
        const val CHANNEL_ID = "TimerChannel"
        const val NOTIFICATION_ID = 1
        const val ACTION_START = "ACTION_START"
        const val ACTION_STOP = "ACTION_STOP"
        const val ACTION_SYNC = "ACTION_SYNC"
    }

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val action = intent?.action
        
        // Recebe dados simples do WebApp
        val startTime = intent?.getLongExtra("start_ts", 0L) ?: 0L
        val elapsed = intent?.getLongExtra("elapsed", 0L) ?: 0L
        val state = intent?.getStringExtra("state") ?: "stopped"

        if (action == ACTION_SYNC || action == ACTION_START) {
            val notification = createNotification(state, startTime, elapsed)
            
            // Inicia o servi√ßo em primeiro plano (Obrigat√≥rio para n√£o ser morto pelo Android)
            if (Build.VERSION.SDK_INT >= 34) {
                startForeground(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE)
            } else {
                startForeground(NOTIFICATION_ID, notification)
            }
        } else if (action == ACTION_STOP) {
            stopForeground(STOP_FOREGROUND_REMOVE)
            stopSelf()
        }

        return START_NOT_STICKY
    }

    private fun createNotification(state: String, startTs: Long, pausedElapsed: Long): Notification {
        val title = if (state == "running") "Em Rota" else "Pausado"
        
        // C√°lculo simples do tempo apenas para exibir o estado atual (snapshot)
        // A contagem real fica no WebApp para evitar dessincronia
        val totalMs = if (state == "running") {
            val base = if (startTs > 0) startTs else System.currentTimeMillis()
            System.currentTimeMillis() - base
        } else {
            pausedElapsed
        }

        val seconds = (totalMs / 1000) % 60
        val minutes = (totalMs / (1000 * 60)) % 60
        val hours = (totalMs / (1000 * 60 * 60))
        val timeString = String.format(Locale.getDefault(), "%02d:%02d:%02d", hours, minutes, seconds)

        // Intent para abrir o app ao clicar
        val intent = Intent(this, MainActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP
        val pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)

        // Notifica√ß√£o Padr√£o (Sem bot√µes, sem crash)
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(timeString) // Mostra o tempo recebido do WebApp
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentIntent(pendingIntent)
            .setOnlyAlertOnce(true)
            .setOngoing(true)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)
            .build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                CHANNEL_ID,
                "Cron√¥metro de Rota",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/WindowMonitorService.kt
================================================================================
package com.motoristapro.android

import android.accessibilityservice.AccessibilityService
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.Display
import android.view.accessibility.AccessibilityEvent
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import org.json.JSONArray
import org.json.JSONObject
import android.graphics.Color

class WindowMonitorService : AccessibilityService() {

    private val executor: ExecutorService = Executors.newSingleThreadExecutor()
    private val mainHandler = Handler(Looper.getMainLooper())
    private var lastCaptureTime = 0L
    
    private val CAPTURE_COOLDOWN = 1000L 
    private val DELAY_FAST = 500L
    private val DELAY_RETRY = 1200L
    
    private val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)

    override fun onServiceConnected() {
        super.onServiceConnected()
        warmUpOcrEngine()
    }

    private fun warmUpOcrEngine() {
        executor.execute {
            try {
                val dummy = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)
                val image = InputImage.fromBitmap(dummy, 0)
        Logger.log("MLKIT", "Enviando imagem para ML Kit Vision...")
                recognizer.process(image)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null || event.packageName == null) return
        val pkgName = event.packageName.toString()

        if (pkgName.contains("uber") || pkgName.contains("99")) {
            if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED ||
                event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED) {
                
                triggerCaptureLogic(pkgName)
            }
        }
    }

    private fun triggerCaptureLogic(pkgName: String) {
        Logger.log("MONITOR", "Gatilho de captura acionado para $pkgName")
        val now = System.currentTimeMillis()
        if (now - lastCaptureTime > CAPTURE_COOLDOWN) {
            lastCaptureTime = now
            scheduleScreenshot(DELAY_FAST, pkgName, isRetry = false)
        }
    }

    private fun scheduleScreenshot(delay: Long, pkgName: String, isRetry: Boolean) {
        mainHandler.postDelayed({
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                
                // FOR√áAR OCULTAR CARD (Fix Duplica√ß√£o)
                try { 
                    sendBroadcast(Intent("com.motoristapro.ACTION_HIDE_CARD"))
                    Thread.sleep(300) 
                } catch(e: Exception) {}

                takeScreenshot(
                    Display.DEFAULT_DISPLAY,
                    executor,
                    object : TakeScreenshotCallback {
                        override fun onSuccess(result: ScreenshotResult) {
                            try {
                                val hardwareBuffer = result.hardwareBuffer
                                val colorSpace = result.colorSpace
                                val bitmap = Bitmap.wrapHardwareBuffer(hardwareBuffer, colorSpace)
                                val copy = bitmap?.copy(Bitmap.Config.ARGB_8888, true)
                                hardwareBuffer.close()
                                
                                if (copy != null) {
                                    // APLICA FILTRO AVAN√áADO (BINARIZA√á√ÉO)
                                    val processedBitmap = preprocessAdvanced(copy)
                                    runOcr(processedBitmap, pkgName, isRetry)
                                }
                            } catch (e: Exception) {
                                Log.e("MotoristaPro", "Erro print: ${e.message}")
                            }
                        }
                        override fun onFailure(errorCode: Int) {}
                    }
                )
            }
        }, delay)
    }

    // === MELHORIA 1: VIS√ÉO DE ALTA PRECIS√ÉO ===
    private fun preprocessAdvanced(original: Bitmap): Bitmap {
        try {
            val width = original.width
            val height = original.height
            val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            val canvas = Canvas(bitmap)
            val paint = Paint()

            // 1. Detectar se √© Modo Noturno (M√©dia de brilho)
            // Se for escuro, INVERTE as cores para ficar Fundo Branco/Letra Preta (OCR prefere assim)
            var isDark = false
            // Amostragem simples no centro da imagem
            val samplePixel = original.getPixel(width / 2, height / 2)
            val lum = (0.299 * Color.red(samplePixel) + 0.587 * Color.green(samplePixel) + 0.114 * Color.blue(samplePixel)) / 255
            if (lum < 0.5) isDark = true

            // Matriz de Cor
            val colorMatrix = ColorMatrix()
            
            // Passo A: Escala de Cinza
            colorMatrix.setSaturation(0f) 

            // Passo B: Alto Contraste (Thresholding via Matriz)
            // Aumenta drasticamente o contraste para 'matar' cinzas m√©dios
            val contrast = 4.0f 
            val scale = floatArrayOf(
                contrast, 0f, 0f, 0f, -128f * contrast + 128f,
                0f, contrast, 0f, 0f, -128f * contrast + 128f,
                0f, 0f, contrast, 0f, -128f * contrast + 128f,
                0f, 0f, 0f, 1f, 0f
            )
            colorMatrix.postConcat(ColorMatrix(scale))

            // Passo C: Invers√£o (se for modo noturno)
            if (isDark) {
                val invert = floatArrayOf(
                    -1f, 0f, 0f, 0f, 255f,
                    0f, -1f, 0f, 0f, 255f,
                    0f, 0f, -1f, 0f, 255f,
                    0f, 0f, 0f, 1f, 0f
                )
                colorMatrix.postConcat(ColorMatrix(invert))
            }

            val filter = ColorMatrixColorFilter(colorMatrix)
            paint.colorFilter = filter
            canvas.drawBitmap(original, 0f, 0f, paint)

            return bitmap
        } catch (e: Exception) {
            return original // Fallback para imagem original se der erro
        }
    }

    private fun runOcr(bitmap: Bitmap, pkgName: String, isRetry: Boolean) {
        val image = InputImage.fromBitmap(bitmap, 0)
        val screenHeight = bitmap.height

        Logger.log("MLKIT", "Enviando imagem para ML Kit Vision...")
        recognizer.process(image)
            .addOnSuccessListener { visionText ->
                val jsonArray = JSONArray()
                
                for (block in visionText.textBlocks) {
                    for (line in block.lines) {
                        val bbox = line.boundingBox
                        if (bbox != null) {
                            val obj = JSONObject()
                            obj.put("text", line.text)
                            obj.put("h", bbox.height())
                            obj.put("y", bbox.top)
                            jsonArray.put(obj)
                        }
                    }
                }

                if (jsonArray.length() > 0) {
                    sendToOverlay(jsonArray.toString(), pkgName, screenHeight)
                } else if (!isRetry) {
                    scheduleScreenshot(DELAY_RETRY - DELAY_FAST, pkgName, true)
                }
            }
    }

    private fun sendToOverlay(jsonData: String, pkg: String, screenH: Int) {
        val intent = Intent("ACTION_PROCESS_TEXT")
        intent.putExtra("JSON_DATA", jsonData)
        intent.putExtra("APP_PACKAGE", pkg)
        intent.putExtra("SCREEN_HEIGHT", screenH)
        intent.setPackage(packageName)
        sendBroadcast(intent)
    }

    override fun onInterrupt() {}
    override fun onDestroy() { super.onDestroy(); executor.shutdown() }
}
