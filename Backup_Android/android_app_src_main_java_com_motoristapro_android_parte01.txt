
================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/ErrorActivity.kt
================================================================================
package com.motoristapro.android

import android.app.Activity
import android.os.Bundle
import android.widget.ScrollView
import android.widget.TextView
import android.graphics.Color
import android.widget.LinearLayout

class ErrorActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val scroll = ScrollView(this)
        val layout = LinearLayout(this)
        layout.orientation = LinearLayout.VERTICAL
        layout.setPadding(50, 50, 50, 50)
        layout.setBackgroundColor(Color.WHITE)

        val title = TextView(this)
        title.text = "ERRO FATAL (CRASH)"
        title.textSize = 24f
        title.setTextColor(Color.RED)
        title.setPadding(0, 0, 0, 30)

        val message = TextView(this)
        message.text = intent.getStringExtra("error") ?: "Erro desconhecido"
        message.textSize = 14f
        message.setTextColor(Color.BLACK)

        layout.addView(title)
        layout.addView(message)
        scroll.addView(layout)

        setContentView(scroll)
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/Logger.kt
================================================================================
package com.motoristapro.android

import android.os.Environment
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

object Logger {
    private const val FILE_NAME = "motorista_full_trace.txt"
    private val dateFormat = SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault())

    fun log(tag: String, msg: String) {
        try {
            val dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            val file = File(dir, FILE_NAME)
            val timestamp = dateFormat.format(Date())
            
            // Formato: [12:00:00.000] [TAG] Mensagem
            val line = "[$timestamp] [$tag] $msg\n"
            
            val writer = FileWriter(file, true)
            writer.append(line)
            writer.flush()
            writer.close()
        } catch (e: Exception) {
            // Falha silenciosa para n√£o travar o app
        }
    }
    
    fun clear() {
        try {
            val dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            val file = File(dir, FILE_NAME)
            if (file.exists()) file.delete()
        } catch (e: Exception) {}
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MainActivity.kt
================================================================================
package com.motoristapro.android

import android.Manifest
import android.accessibilityservice.AccessibilityServiceInfo
import android.app.AlertDialog
import android.app.Dialog
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Message
import android.provider.Settings
import android.view.accessibility.AccessibilityManager
import android.webkit.JavascriptInterface
import android.webkit.WebChromeClient
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.google.firebase.messaging.FirebaseMessaging

class MainActivity : ComponentActivity() {

    private lateinit var webView: WebView
    private val NOTIFICATION_PERMISSION_CODE = 101
    
    private val jsReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val js = intent?.getStringExtra("js")
            if (js != null) {
                webView.evaluateJavascript(js, null)
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        webView = findViewById(R.id.webView)
        setupWebView(webView)
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            registerReceiver(jsReceiver, IntentFilter("wwebview.js_command"), Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(jsReceiver, IntentFilter("wwebview.js_command"))
        }

        handleIntent(intent)
        askNotificationPermission()
    }
    
    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        handleIntent(intent)
    }

    private fun handleIntent(intent: Intent?) {
        if (intent?.action == "OPEN_ADD_SCREEN") {
            val h = intent.getIntExtra("h_val", 0)
            val m = intent.getIntExtra("m_val", 0)
            webView.loadUrl("https://motorista-pro-app.onrender.com/adicionar?tempo_cronometro=$h:$m")
        } else if (webView.url == null) {
            webView.loadUrl("https://motorista-pro-app.onrender.com")
        }
    }

    private fun setupWebView(view: WebView) {
        val settings = view.settings
        settings.javaScriptEnabled = true
        settings.domStorageEnabled = true
        val defaultUA = settings.userAgentString
        settings.userAgentString = defaultUA.replace("; wv", "") + " (MotoristaPro)"
        settings.setSupportMultipleWindows(true)
        settings.javaScriptCanOpenWindowsAutomatically = true
        
        if (view == webView) {
            view.addJavascriptInterface(WebAppInterface(this), "MotoristaProAndroid")
        }

        view.webViewClient = WebViewClient()
        view.webChromeClient = object : WebChromeClient() {
            override fun onCreateWindow(view: WebView?, isDialog: Boolean, isUserGesture: Boolean, resultMsg: Message?): Boolean {
                val newWebView = WebView(this@MainActivity)
                setupWebView(newWebView)
                val dialog = Dialog(this@MainActivity, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
                dialog.setContentView(newWebView)
                dialog.show()
                newWebView.webChromeClient = object : WebChromeClient() {
                    override fun onCloseWindow(window: WebView?) { dialog.dismiss() }
                }
                val transport = resultMsg?.obj as WebView.WebViewTransport
                transport.webView = newWebView
                resultMsg.sendToTarget()
                return true
            }
        }
    }

    private fun askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= 33) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), NOTIFICATION_PERMISSION_CODE)
            }
        }
    }

    inner class WebAppInterface(private val context: Context) {
        @JavascriptInterface
        fun startRobot() { runOnUiThread { checkAndRequestPermissions() } }

        @JavascriptInterface
        fun requestPermission() { runOnUiThread { checkAndRequestPermissions() } }

        @JavascriptInterface
        fun subscribeToPush(userId: String) {
            FirebaseMessaging.getInstance().subscribeToTopic("all_users")
            if (userId.isNotEmpty()) FirebaseMessaging.getInstance().subscribeToTopic("user_$userId")
        }
        
        @JavascriptInterface
        fun syncTimer(state: String, startTs: Long, elapsed: Long) {
            val intent = Intent(context, TimerService::class.java)
            intent.action = TimerService.ACTION_SYNC
            intent.putExtra("state", state)
            intent.putExtra("start_ts", startTs)
            intent.putExtra("elapsed", elapsed)
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(intent)
            } else {
                context.startService(intent)
            }
        }
    }

    private fun checkAndRequestPermissions() {
        if (!Settings.canDrawOverlays(this)) {
            showExplanationDialog("Permiss√£o de Sobreposi√ß√£o", "Necess√°rio para exibir o lucro flutuante.") {
                startActivity(Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName")))
            }
            return
        }
        if (!isAccessibilityServiceEnabled()) {
            showExplanationDialog("Ativar Leitura", "Necess√°rio para ler o pre√ßo da corrida.") {
                startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))
            }
            return
        }
        startOcrService()
    }

    private fun startOcrService() {
        try {
            val intent = Intent(this, OcrService::class.java)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent) else startService(intent)
            Toast.makeText(this, "ü§ñ Rob√¥ Iniciado!", Toast.LENGTH_LONG).show()
        } catch (e: Exception) {
            Toast.makeText(this, "Erro: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    private fun showExplanationDialog(title: String, message: String, positiveAction: () -> Unit) {
        AlertDialog.Builder(this).setTitle(title).setMessage(message)
            .setPositiveButton("Configurar") { _, _ -> positiveAction() }
            .setNegativeButton("Cancelar", null).setCancelable(false).show()
    }

    private fun isAccessibilityServiceEnabled(): Boolean {
        val am = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
        val enabledServices = am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_GENERIC)
        for (service in enabledServices) {
            if (service.resolveInfo.serviceInfo.packageName == packageName &&
                service.resolveInfo.serviceInfo.name.endsWith("WindowMonitorService")) return true
        }
        return false
    }
    
    override fun onDestroy() {
        super.onDestroy()
        try { unregisterReceiver(jsReceiver) } catch (e: Exception) {}
    }
    
    override fun onBackPressed() { if (webView.canGoBack()) webView.goBack() else super.onBackPressed() }
}

================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MotoristaApp.kt
================================================================================
package com.motoristapro.android

import android.app.Application
import android.content.Intent
import android.os.Process
import java.io.PrintWriter
import java.io.StringWriter

class MotoristaApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Define o capturador padr√£o de exce√ß√µes n√£o tratadas
        Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->
            handleUncaughtException(thread, throwable)
        }
    }

    private fun handleUncaughtException(thread: Thread, e: Throwable) {
        e.printStackTrace() // Loga no console se poss√≠vel

        val sw = StringWriter()
        e.printStackTrace(PrintWriter(sw))
        val stackTrace = sw.toString()

        // Abre uma Activity de Erro para mostrar o texto na tela
        val intent = Intent(applicationContext, ErrorActivity::class.java)
        intent.putExtra("error", stackTrace)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
        startActivity(intent)

        Process.killProcess(Process.myPid())
        System.exit(1)
    }
}


================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/MyFirebaseMessagingService.kt
================================================================================
package com.motoristapro.android

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage

class MyFirebaseMessagingService : FirebaseMessagingService() {

    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        // Verifica se a mensagem tem payload de notifica√ß√£o
        remoteMessage.notification?.let {
            sendNotification(it.title ?: "Nova Mensagem", it.body ?: "")
        }
    }

    private fun sendNotification(title: String, messageBody: String) {
        val intent = Intent(this, MainActivity::class.java)
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
        
        val pendingIntent = PendingIntent.getActivity(
            this, 0, intent,
            PendingIntent.FLAG_ONE_SHOT or PendingIntent.FLAG_IMMUTABLE
        )

        val channelId = "motorista_pro_channel"
        val notificationBuilder = NotificationCompat.Builder(this, channelId)
            .setSmallIcon(R.mipmap.ic_launcher) // √çcone padr√£o do app
            .setContentTitle(title)
            .setContentText(messageBody)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_HIGH)

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        // Cria o canal de notifica√ß√£o (Necess√°rio para Android 8.0+)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                "Avisos Motorista Pro",
                NotificationManager.IMPORTANCE_HIGH
            )
            notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(System.currentTimeMillis().toInt(), notificationBuilder.build())
    }
}

================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/OcrService.kt
================================================================================
package com.motoristapro.android

import android.app.Service
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.ServiceInfo
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.graphics.Color
import android.graphics.Outline
import android.graphics.PixelFormat
import android.graphics.Typeface
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Environment
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.ViewOutlineProvider
import android.view.WindowManager
import android.widget.Button
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.core.app.NotificationCompat
import org.json.JSONArray
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.regex.Pattern
import kotlin.math.abs

class OcrService : Service() {

    private lateinit var windowManager: WindowManager
    private val autoHideHandler = Handler(Looper.getMainLooper())
    private val autoHideRunnable = Runnable { hideCard() }
    
    private val AUTO_HIDE_DELAY = 7000L 

    private var bubbleView: View? = null
    private var menuView: View? = null
    private var settingsView: View? = null
    private var infoCardView: LinearLayout? = null
    private var iconView: ImageView? = null
    
    private var tvMenuPauseTitle: TextView? = null
    private var tvMenuPauseIcon: TextView? = null
    
    private lateinit var tvAppBadge: TextView
    private lateinit var tvValorTopo: TextView
    private lateinit var tvDadosMeio: TextView
    private lateinit var tvResultadosBaixo: TextView
    private lateinit var tvDicaAcao: TextView
    
    private lateinit var etGoodKm: EditText
    private lateinit var etBadKm: EditText
    private lateinit var etGoodHour: EditText
    private lateinit var etBadHour: EditText

    private var goodKm: Double = 2.0
    private var badKm: Double = 1.5
    private var goodHour: Double = 60.0
    private var badHour: Double = 40.0
    
    private var isMonitoring: Boolean = true
    private var isMenuOpen: Boolean = false
    private var isSettingsOpen: Boolean = false
    
    private lateinit var bubbleParams: WindowManager.LayoutParams
    private lateinit var menuParams: WindowManager.LayoutParams
    private lateinit var settingsParams: WindowManager.LayoutParams
    private lateinit var cardParams: WindowManager.LayoutParams

    
    private val hideCardReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (infoCardView?.visibility == View.VISIBLE) {
                infoCardView?.visibility = View.GONE
                bubbleView?.visibility = View.GONE // Oculta tudo para o print ser limpo
            }
        }
    }
    
    private val textReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val jsonData = intent?.getStringExtra("JSON_DATA")
            val pkg = intent?.getStringExtra("APP_PACKAGE") ?: ""
            val screenH = intent?.getIntExtra("SCREEN_HEIGHT", 2000) ?: 2000
            
            if (!jsonData.isNullOrEmpty()) {
                analyzeSmartData(jsonData, pkg, screenH)
            }
        }
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onCreate() {
        super.onCreate()
        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        loadConfigs()
        Logger.log("LIFECYCLE", "OcrService Iniciado. Configs carregadas: KM Bom=$goodKm, Hora Boa=$goodHour")
        val filter = IntentFilter("ACTION_PROCESS_TEXT")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(textReceiver, filter, Context.RECEIVER_EXPORTED)
        } else {
            registerReceiver(textReceiver, filter)
        registerReceiver(hideCardReceiver, IntentFilter("com.motoristapro.ACTION_HIDE_CARD"))
        }
        try {
            startForegroundServiceCompat()
            createBubble()
            createMenu()
            createSettingsView()
            createInfoCard()
            saveLog("--- ROB√î V14 (ANTI-BORR√ÉO) INICIADO ---")
        } catch (e: Exception) { e.printStackTrace() }
    }

    private fun saveLog(msg: String) {
        try {
            val dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            val file = File(dir, "motorista_debug.txt")
            val timestamp = SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(Date())
            val writer = FileWriter(file, true)
            writer.append("[$timestamp] $msg\n")
            writer.flush()
            writer.close()
        } catch (e: Exception) {}
    }

    private fun startForegroundServiceCompat() {
        val channelId = "ocr_service_channel"
        val channel = NotificationChannel(channelId, "Motorista Pro", NotificationManager.IMPORTANCE_LOW)
        getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        val stopIntent = Intent(this, OcrService::class.java).apply { action = "STOP_SERVICE" }
        val stopPendingIntent = PendingIntent.getService(this, 0, stopIntent, PendingIntent.FLAG_IMMUTABLE)
        val notification = NotificationCompat.Builder(this, channelId)
            .setContentTitle("Motorista Pro")
            .setSmallIcon(R.mipmap.ic_launcher)
            .addAction(android.R.drawable.ic_menu_close_clear_cancel, "Parar", stopPendingIntent)
            .setOngoing(true)
            .build()
        if (Build.VERSION.SDK_INT >= 34) {
            startForeground(1, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            startForeground(1, notification)
        }
    }

    private fun sanitizeOcrErrors(input: String): String {
        // Corre√ß√£o Leetspeak b√°sica
        var text = input.lowercase().replace("\n", " ").replace(",", ".")
        
        // 1. Corrige a palavra "minutos" borrada (ex: m1nut05)
        text = text.replace(Regex("m[1i]nut[o0]5?"), "min")
                   .replace(Regex("m[1i]n"), "min")
                   
        // 2. Corrige n√∫meros apenas se tiver contexto
        if (text.contains("km") || text.contains("min") || text.contains("m ") || text.contains("h")) {
            text = text.replace("o", "0")
                       .replace("l", "1")
                       .replace("i", "1")
                       .replace("s", "5")
                       .replace("b", "8")
        }
        return text
    }

    private fun analyzeSmartData(jsonString: String, pkgName: String, screenHeight: Int) {
        Logger.log("ENGINE", "Iniciando an√°lise de dados OCR...")
        try {
            if (!isMonitoring) return

            val blocks = JSONArray(jsonString)
            var bestPrice = 0.0
            var maxPriceFontSize = 0
            
            var totalDist = 0.0
            var totalTime = 0.0
            
            var distCount = 0
            var timeCount = 0

            val detectedApp = if (pkgName.contains("taxis99") || pkgName.contains("didi") || pkgName.contains("99")) "99" else "UBER"
            val ignoreTopLimit = screenHeight * 0.10

            val sbLog = StringBuilder("AN√ÅLISE [$detectedApp]:\n")

            for (i in 0 until blocks.length()) {
                val obj = blocks.getJSONObject(i)
                val rawText = obj.getString("text")
                val h = obj.getInt("h")
                val y = obj.getInt("y")
                
                if (y < ignoreTopLimit) continue

                val cleanText = sanitizeOcrErrors(rawText)

                // --- FIX: IGNORAR PROMO√á√ïES UBER (EVITA LER 'GANHE R$ 60') ---
                if (cleanText.contains("ganhe r$") || cleanText.contains("a mais por") || cleanText.contains("viagens e ganhe") || cleanText.contains("meta de ganhos")) {
                    sbLog.append("      [IGNORADO] Texto de promo√ß√£o detectado\n")
                    continue
                }
                

                // --- FIX: IGNORAR AVISO 'MAIS DE 30 MIN' ---
                
                // --- FIX: EVITAR AUTO-LEITURA E SHOWROOM ---
                if (cleanText.contains("r$/km") || cleanText.contains("r$/h") || cleanText.contains("5h0wr00m") || cleanText.contains("showroom")) {
                    continue
                }
        
                if (cleanText.contains("ma15 de 30") || cleanText.contains("mais de 30") || cleanText.contains("ma1s de 30")) {
                    sbLog.append("      [IGNORADO] Aviso 'mais de 30 min' detectado\n")
                    continue
                }
                
                // --- FIX: IGNORAR DIST√ÇNCIA EM METROS COMO TEMPO (REFRA√á√ÉO) ---
                if (cleanText.matches(Regex(".*\\d+\\s*m\\b.*")) && !cleanText.contains("min")) {
                     // Se tem 'm' mas n√£o tem 'min', √© metro, n√£o tempo (refor√ßo de seguran√ßa)
                }
            

                // --- FILTRO DE RU√çDO (BASEADO NOS LOGS) ---
                if (cleanText.contains("mapa de chamada") || cleanText.contains("chamadas") || cleanText == "30 m") {
                    continue
                }
                            Logger.log("OCR_LINE", "RAW: '$rawText' -> CLEAN: '$cleanText'")
                
                if (cleanText.any { it.isDigit() }) {
                    sbLog.append("   RAW: '$rawText' -> CLEAN: '$cleanText'\n")
                }

                // A. PRE√áO
                val matPrice = Pattern.compile("(?:r\\$|rs)\\s*([0-9]+(?:\\.[0-9]{2})?)").matcher(cleanText)
                if (matPrice.find()) {
                    val v = matPrice.group(1)?.toDoubleOrNull() ?: 0.0
                    if (v > 4.5) {
                        if (h > maxPriceFontSize) {
                            maxPriceFontSize = h; bestPrice = v
                        } else if (h == maxPriceFontSize && v > bestPrice) {
                            bestPrice = v
                        }
                    }
                }
                if (bestPrice == 0.0 && h > 80) {
                     val matPrice2 = Pattern.compile("^([0-9]+(?:\\.[0-9]{2}))$").matcher(cleanText.trim())
                     if (matPrice2.find()) {
                         val v = matPrice2.group(1)?.toDoubleOrNull() ?: 0.0
                         if (v > 5.0 && v < 500.0) { bestPrice = v; maxPriceFontSize = h }
                     }
                }

                // B. DIST√ÇNCIA (Par√™nteses ou Contexto de "de distancia")
                // Uber usa "6 minutos (2.0 km) de distancia"
                val matDist = Pattern.compile("\\(?([0-9]+(?:\\.[0-9]+)?)\\s*(km|m)\\)?").matcher(cleanText)
                while (matDist.find()) {
                    val valStr = matDist.group(1) ?: "0"
                    val unit = matDist.group(2) ?: "km"
                    var value = valStr.toDoubleOrNull() ?: 0.0
                    
                    if (unit == "m") value /= 1000.0
                    
                    // S√≥ aceita se fizer sentido (0.1 a 300km)
                    if (value > 0.1 && value < 300.0) {
                        totalDist += value
                        distCount++
                        sbLog.append("      FOUND DIST: $value km\n")
                    }
                }

                // C. TEMPO (REGEX ANTI-BORR√ÉO)
                // Remove rel√≥gio 10:42
                var textForTime = cleanText.replace(Regex("\\d{1,2}:\\d{2}"), " ")
                
                // Horas: "1h", "1 h", "1hr"
                val matHour = Pattern.compile("(\\d+)\\s*(?:h|hr|hrs|hora|horas)\\b")
                val mHour = matHour.matcher(textForTime)
                while (mHour.find()) {
                    val hVal = mHour.group(1)?.toDoubleOrNull() ?: 0.0
                    if (hVal > 0 && hVal < 24) { 
                        totalTime += (hVal * 60)
                        timeCount++
                        sbLog.append("      FOUND HOUR: $hVal h\n")
                    }
                }

                // Minutos: "min", "minutos" (E varia√ß√µes borradas que o sanitize j√° arrumou para 'min')
                val matMin = Pattern.compile("(\\d+)\\s*(?:min|minutos|m1n|m1ns|mins)(?!in|etro|l|e|a|o)")
                // O lookahead negativo (?!in|etro) impede que pegue "min" de "termina" ou "metro"
                val mMin = matMin.matcher(textForTime)
                while (mMin.find()) {
                    val mVal = mMin.group(1)?.toDoubleOrNull() ?: 0.0
                    if (mVal > 0 && mVal < 600) { 
                        totalTime += mVal
                        timeCount++
                        sbLog.append("      FOUND MIN: $mVal min\n")
                    }
                }
            }

            // D. VALIDA√á√ÉO
            val isValidReading = (bestPrice > 0.0) && ((totalDist > 0.0) || (totalTime > 0.0))
            
            sbLog.append("   RESULTADO: R$$bestPrice | D:$totalDist ($distCount) | T:$totalTime ($timeCount)\n")
            saveLog(sbLog.toString())

            if (isValidReading) {
                // Se tempo for 0, tenta 1.0, mas isso √© sinal de que o regex falhou.
                val safeDist = if (totalDist == 0.0) 0.1 else totalDist
                val safeTime = if (totalTime == 0.0) 1.0 else totalTime 

                val valPerKm = bestPrice / safeDist
                val valPerHour = (bestPrice / safeTime) * 60.0
                
                Logger.log("CALC", "Calculando: R$$bestPrice / ${safeDist}km = ${valPerKm}/km | ($bestPrice / $safeTime) * 60 = ${valPerHour}/h")
                val resultStyle = if (valPerKm >= goodKm && valPerHour >= goodHour) {
                    Triple(Color.parseColor("#4ADE80"), "√ìTIMA üöÄ", "#334ADE80")
                } else if (valPerKm <= badKm && valPerHour <= badHour) {
                    Triple(Color.parseColor("#F87171"), "RECUSAR üõë", "#33F87171")
                } else {
                    Triple(Color.parseColor("#FACC15"), "ANALISAR ü§î", "#33FACC15")
                }
                
                val (finalColor, finalMsg, finalAlpha) = resultStyle
                val bgDica = GradientDrawable().apply { cornerRadius = 15f; setColor(Color.parseColor(finalAlpha)) }
                
                showCard(bestPrice, totalDist, totalTime, valPerKm, valPerHour, finalColor, finalMsg, bgDica, detectedApp)
            }

        } catch (e: Exception) { 
            e.printStackTrace()
            saveLog("ERRO FATAL: ${e.message}")
        }
    }

    // --- UI METHODS ---
    
    private fun showCard(price: Double, dist: Double, time: Double, valKm: Double, valHora: Double, color: Int, msg: String, bgDica: Drawable, detectedApp: String) {
        Handler(Looper.getMainLooper()).post {
            autoHideHandler.removeCallbacks(autoHideRunnable)
            
            bubbleView?.visibility = View.GONE
            infoCardView?.visibility = View.VISIBLE
            
            val badgeBg = GradientDrawable().apply { cornerRadius = 10f }

            if (detectedApp == "UBER") {
                tvAppBadge.visibility = View.VISIBLE; tvAppBadge.text = "UBER"; tvAppBadge.setTextColor(Color.WHITE); badgeBg.setColor(Color.BLACK)
            } else if (detectedApp == "99") {
                tvAppBadge.visibility = View.VISIBLE; tvAppBadge.text = "99"; tvAppBadge.setTextColor(Color.BLACK); badgeBg.setColor(Color.parseColor("#F7C948"))
            } else {
                tvAppBadge.visibility = View.GONE
            }

            tvAppBadge.background = badgeBg
            tvValorTopo.text = String.format("R$ %.2f", price)
            tvValorTopo.setTextColor(color) 
            
            tvDadosMeio.text = String.format("%.1f km ‚Ä¢ %.0f min", dist, time)
            tvResultadosBaixo.text = String.format("R$ %.2f/km ‚Ä¢ R$ %.0f/h", valKm, valHora)
            tvResultadosBaixo.setTextColor(color)
            tvDicaAcao.text = msg
            tvDicaAcao.setTextColor(color)
            tvDicaAcao.background = bgDica
            
            autoHideHandler.postDelayed(autoHideRunnable, AUTO_HIDE_DELAY)
        }
    }
    
    private fun hideCard() { Handler(Looper.getMainLooper()).post { autoHideHandler.removeCallbacks(autoHideRunnable); infoCardView?.visibility = View.GONE; if (isMonitoring) bubbleView?.visibility = View.VISIBLE } }
    
    private fun createInfoCard() {
        val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
        val savedX = prefs.getInt("card_x", 0)
        val savedY = prefs.getInt("card_y", 100)
        infoCardView = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(30, 25, 30, 25); visibility = View.GONE; background = GradientDrawable().apply { cornerRadius = 40f; setColor(Color.parseColor("#E6334155")); setStroke(2, Color.parseColor("#33FFFFFF")) } }
        tvAppBadge = TextView(this).apply { text="APP"; setTextColor(Color.WHITE); gravity=Gravity.CENTER; textSize=10f; typeface=Typeface.DEFAULT_BOLD; setPadding(20,5,20,5); layoutParams=LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { gravity=Gravity.CENTER_HORIZONTAL; bottomMargin=10 } }
        tvValorTopo = TextView(this).apply { text="--"; textSize=26f; setTextColor(Color.WHITE); typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER }
        tvDadosMeio = TextView(this).apply { text="--"; textSize=14f; setTextColor(Color.LTGRAY); gravity=Gravity.CENTER }
        tvResultadosBaixo = TextView(this).apply { text="--"; textSize=18f; typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER }
        tvDicaAcao = TextView(this).apply { text="..."; textSize=14f; typeface=Typeface.DEFAULT_BOLD; gravity=Gravity.CENTER; setPadding(10,5,10,5) }
        infoCardView!!.addView(tvAppBadge); infoCardView!!.addView(tvValorTopo); infoCardView!!.addView(tvDadosMeio); infoCardView!!.addView(tvResultadosBaixo); infoCardView!!.addView(tvDicaAcao)
        cardParams = WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START; x = savedX; y = savedY; width = (resources.displayMetrics.widthPixels * 0.65).toInt() }
        
        infoCardView!!.setOnTouchListener(object : View.OnTouchListener {
            private var iX=0; private var iY=0; private var iTX=0f; private var iTY=0f; private var isDrag=false
            override fun onTouch(v: View?, event: MotionEvent?): Boolean {
                if (event == null) return false
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> { iX = cardParams.x; iY = cardParams.y; iTX = event.rawX; iTY = event.rawY; isDrag = false; return true }
                    MotionEvent.ACTION_MOVE -> { val dx = (event.rawX - iTX).toInt(); val dy = (event.rawY - iTY).toInt(); if (abs(dx) > 10 || abs(dy) > 10) { isDrag = true; cardParams.x = iX + dx; cardParams.y = iY + dy; windowManager.updateViewLayout(infoCardView, cardParams) }; return true }
                    MotionEvent.ACTION_UP -> { if (isDrag) { prefs.edit().putInt("card_x", cardParams.x).putInt("card_y", cardParams.y).apply() } else { hideCard() }; return true }
                }
                return false
            }
        })
        windowManager.addView(infoCardView, cardParams)
    }

    private fun toggleMonitoring() { isMonitoring = !isMonitoring; iconView?.alpha = if(isMonitoring) 1f else 0.5f; if(!isMonitoring) hideCard(); Toast.makeText(this, if(isMonitoring) "Ativo" else "Pausado", Toast.LENGTH_SHORT).show() }
    private fun toggleMenu() { if(isMenuOpen) closeMenu() else openMenu() }
    private fun openSettings() { isSettingsOpen = true; settingsView!!.visibility = View.VISIBLE; windowManager.updateViewLayout(settingsView, settingsParams) }
    private fun closeSettings() { isSettingsOpen = false; settingsView!!.visibility = View.GONE }
    private fun openMenu() { 
        isMenuOpen = true; menuParams.x = bubbleParams.x; menuParams.y = bubbleParams.y + bubbleView!!.height + 15
        if (isMonitoring) { tvMenuPauseTitle?.text = "Pausar Leitura"; tvMenuPauseIcon?.text = "‚è∏" } else { tvMenuPauseTitle?.text = "Retomar Leitura"; tvMenuPauseIcon?.text = "‚ñ∂Ô∏è" }
        menuView!!.visibility = View.VISIBLE; windowManager.updateViewLayout(menuView, menuParams); Handler(Looper.getMainLooper()).postDelayed({ if (isMenuOpen) closeMenu() }, 5000) 
    }
    private fun closeMenu() { isMenuOpen = false; menuView!!.visibility = View.GONE }
    private fun openApp(target: String) { try { val i = packageManager.getLaunchIntentForPackage(packageName); i?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); closeMenu() } catch (e: Exception) { Toast.makeText(this, "Erro", Toast.LENGTH_SHORT).show() } }

    private fun createBubble() {
        val bubbleLayout = FrameLayout(this)
        iconView = ImageView(this).apply { setImageResource(R.mipmap.ic_launcher_round); scaleType = ImageView.ScaleType.CENTER_CROP; clipToOutline = true; outlineProvider = object : ViewOutlineProvider() { override fun getOutline(view: View, outline: Outline) { outline.setOval(0, 0, view.width, view.height) } }; elevation = 20f }
        bubbleLayout.addView(iconView, FrameLayout.LayoutParams(150, 150))
        bubbleLayout.setOnTouchListener(object : View.OnTouchListener {
            private var iX=0; private var iY=0; private var iTX=0f; private var iTY=0f; private var drag=false
            override fun onTouch(v: View?, e: MotionEvent?): Boolean {
                when(e!!.action) {
                    MotionEvent.ACTION_DOWN->{iX=bubbleParams.x;iY=bubbleParams.y;iTX=e.rawX;iTY=e.rawY;drag=false;return true}
                    MotionEvent.ACTION_MOVE->{val dx=(e.rawX-iTX).toInt();val dy=(e.rawY-iTY).toInt();if(abs(dx)>10||abs(dy)>10){drag=true;bubbleParams.x=iX+dx;bubbleParams.y=iY+dy;windowManager.updateViewLayout(bubbleView,bubbleParams);if(isMenuOpen)closeMenu()};return true}
                    MotionEvent.ACTION_UP->{if(!drag)toggleMenu();return true}
                }
                return false
            }
        })
        bubbleView = bubbleLayout
        bubbleParams = WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START; x = 20; y = 300 }
        windowManager.addView(bubbleView, bubbleParams)
    }

    private fun createMenu() {
        val layout = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(0, 20, 0, 20); background = GradientDrawable().apply { setColor(Color.WHITE); cornerRadius = 30f; setStroke(1, Color.parseColor("#E2E8F0")) }; elevation = 40f }
        layout.addView(TextView(this).apply { text = "MOTORISTA PRO"; textSize = 12f; setTextColor(Color.parseColor("#64748B")); typeface = Typeface.DEFAULT_BOLD; gravity = Gravity.CENTER; setPadding(0, 10, 0, 25) })
        layout.addView(View(this).apply { layoutParams = LinearLayout.LayoutParams(-1, 2); setBackgroundColor(Color.parseColor("#F1F5F9")) })
        val btnPause = createMenuItem("‚èØ", "Pausar Leitura", Color.parseColor("#0F172A")) { toggleMonitoring(); closeMenu() }
        tvMenuPauseIcon = btnPause.getChildAt(0) as TextView; tvMenuPauseTitle = btnPause.getChildAt(1) as TextView; layout.addView(btnPause)
        layout.addView(createMenuItem("‚öôÔ∏è", "Configura√ß√µes", Color.parseColor("#0F172A")) { closeMenu(); openSettings() })
        layout.addView(createMenuItem("üì±", "Abrir Aplicativo", Color.parseColor("#2563EB")) { openApp("home"); closeMenu() })
        layout.addView(View(this).apply { layoutParams = LinearLayout.LayoutParams(-1, 2).apply { setMargins(40, 15, 40, 15) }; setBackgroundColor(Color.parseColor("#F1F5F9")) })
        layout.addView(createMenuItem("‚ùå", "Encerrar Tudo", Color.parseColor("#EF4444")) { stopSelf() })
        menuView = layout
        menuParams = WindowManager.LayoutParams(600, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT).apply { gravity = Gravity.TOP or Gravity.START }
        menuView!!.visibility = View.GONE
        windowManager.addView(menuView, menuParams)
    }
    
    private fun createMenuItem(icon: String, text: String, textColor: Int, onClick: () -> Unit): LinearLayout {
        val container = LinearLayout(this).apply { orientation = LinearLayout.HORIZONTAL; gravity = Gravity.CENTER_VERTICAL; setPadding(50, 35, 50, 35); isClickable = true; setBackgroundColor(Color.TRANSPARENT); setOnClickListener { onClick() } }
        val tvIcon = TextView(this).apply { this.text = icon; textSize = 20f; setPadding(0, 0, 40, 0); setTextColor(textColor) }
        val tvText = TextView(this).apply { this.text = text; textSize = 15f; setTextColor(textColor); typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL) }
        container.addView(tvIcon); container.addView(tvText)
        return container
    }

    private fun createSettingsView() {
        val layout = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL; setPadding(50, 50, 50, 50); background = GradientDrawable().apply { setColor(Color.WHITE); cornerRadius = 45f } }
        val txtExpl = TextView(this).apply { text="COMO FUNCIONA A L√ìGICA DE CORES:\n\nüü¢ VERDE: Se (R$/KM >= Meta) E (R$/H >= Meta)\nüî¥ VERMELHO: Se (R$/KM <= Ruim) E (R$/H <= Ruim)\nüü° AMARELO: Qualquer outra combina√ß√£o mista."; textSize=12f; setTextColor(Color.parseColor("#64748B")); setPadding(0,0,0,30) }
        layout.addView(txtExpl)
        fun mkInp(t: String, v: Double): EditText { val et = EditText(this).apply { setText(v.toString()); inputType = 8194; setTextColor(Color.BLACK) }; layout.addView(TextView(this).apply { text = t; setTextColor(Color.GRAY) }); layout.addView(et); return et }
        etGoodKm = mkInp("KM Bom", goodKm); etBadKm = mkInp("KM Ruim", badKm); etGoodHour = mkInp("Hora Boa", goodHour); etBadHour = mkInp("Hora Ruim", badHour)
        val btnSave = Button(this).apply { text = "SALVAR"; setOnClickListener { saveConfigsLocally() } }; layout.addView(btnSave)
        settingsView = layout
        settingsParams = WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, WindowManager.LayoutParams.FLAG_DIM_BEHIND, PixelFormat.TRANSLUCENT).apply { dimAmount = 0.5f; gravity = Gravity.CENTER }
        settingsView!!.visibility = View.GONE
        windowManager.addView(settingsView, settingsParams)
    }

    private fun saveConfigsLocally() {
        try {
            val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
            goodKm = etGoodKm.text.toString().toDoubleOrNull() ?: 2.0; badKm = etBadKm.text.toString().toDoubleOrNull() ?: 1.5; goodHour = etGoodHour.text.toString().toDoubleOrNull() ?: 60.0; badHour = etBadHour.text.toString().toDoubleOrNull() ?: 40.0
            prefs.edit().putFloat("good_km", goodKm.toFloat()).putFloat("bad_km", badKm.toFloat()).putFloat("good_hour", goodHour.toFloat()).putFloat("bad_hour", badHour.toFloat()).apply()
            closeSettings(); Toast.makeText(this, "Salvo", Toast.LENGTH_SHORT).show()
        } catch (e: Exception) {}
    }
    
    private fun loadConfigs() {
        Logger.log("LIFECYCLE", "OcrService Iniciado. Configs carregadas: KM Bom=$goodKm, Hora Boa=$goodHour")
        val prefs = getSharedPreferences("OCR_PREFS", Context.MODE_PRIVATE)
        goodKm = prefs.getFloat("good_km", 2.0f).toDouble(); badKm = prefs.getFloat("bad_km", 1.5f).toDouble(); goodHour = prefs.getFloat("good_hour", 60.0f).toDouble(); badHour = prefs.getFloat("bad_hour", 40.0f).toDouble()
    }

    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(textReceiver)
        try { 
            if (bubbleView != null) windowManager.removeView(bubbleView)
            if (menuView != null) windowManager.removeView(menuView)
            if (settingsView != null) windowManager.removeView(settingsView)
            if (infoCardView != null) windowManager.removeView(infoCardView)
        } catch (e: Exception) {}
    }
}

================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/TimerService.kt
================================================================================
package com.motoristapro.android

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.content.pm.ServiceInfo
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import java.util.Locale

class TimerService : Service() {

    companion object {
        const val CHANNEL_ID = "TimerChannel"
        const val NOTIFICATION_ID = 1
        const val ACTION_START = "ACTION_START"
        const val ACTION_STOP = "ACTION_STOP"
        const val ACTION_PAUSE = "ACTION_PAUSE"
        const val ACTION_SYNC = "ACTION_SYNC"
    }

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val action = intent?.action
        
        // Dados vindos do WebApp
        val startTime = intent?.getLongExtra("start_time", 0L) ?: 0L
        val elapsed = intent?.getLongExtra("elapsed", 0L) ?: 0L
        val state = intent?.getStringExtra("state") ?: "stopped"

        if (action == ACTION_SYNC || action == ACTION_START) {
            val notification = createNotification(state, startTime, elapsed)
            
            // CORRE√á√ÉO CR√çTICA ANDROID 14 (SDK 34)
            if (Build.VERSION.SDK_INT >= 34) { // Android 14+
                startForeground(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE)
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { // Android 10+
                startForeground(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE)
            } else {
                startForeground(NOTIFICATION_ID, notification)
            }
        } else if (action == ACTION_STOP) {
            stopForeground(STOP_FOREGROUND_REMOVE)
            stopSelf()
        }

        return START_NOT_STICKY
    }

    private fun createNotification(state: String, startTs: Long, pausedElapsed: Long): Notification {
        val title = if (state == "running") "Em Rota" else "Pausado"
        
        // C√°lculo do tempo para exibir
        val totalMs = if (state == "running") {
            System.currentTimeMillis() - startTs
        } else {
            pausedElapsed
        }
        
        val seconds = (totalMs / 1000) % 60
        val minutes = (totalMs / (1000 * 60)) % 60
        val hours = (totalMs / (1000 * 60 * 60))
        val timeString = String.format(Locale.getDefault(), "%02d:%02d:%02d", hours, minutes, seconds)

        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(timeString)
            .setSmallIcon(R.mipmap.ic_launcher) // Certifique-se que existe, sen√£o use android.R.drawable.ic_media_play
            .setContentIntent(pendingIntent)
            .setOnlyAlertOnce(true)
            .setOngoing(true)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)
            .build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                CHANNEL_ID,
                "Cron√¥metro de Rota",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}

================================================================================
ARQUIVO: app/src/main/java/com/motoristapro/android/WindowMonitorService.kt
================================================================================
package com.motoristapro.android

import android.accessibilityservice.AccessibilityService
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.Display
import android.view.accessibility.AccessibilityEvent
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import org.json.JSONArray
import org.json.JSONObject
import android.graphics.Color

class WindowMonitorService : AccessibilityService() {

    private val executor: ExecutorService = Executors.newSingleThreadExecutor()
    private val mainHandler = Handler(Looper.getMainLooper())
    private var lastCaptureTime = 0L
    
    private val CAPTURE_COOLDOWN = 1000L 
    private val DELAY_FAST = 500L
    private val DELAY_RETRY = 1200L
    
    private val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)

    override fun onServiceConnected() {
        super.onServiceConnected()
        warmUpOcrEngine()
    }

    private fun warmUpOcrEngine() {
        executor.execute {
            try {
                val dummy = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)
                val image = InputImage.fromBitmap(dummy, 0)
        Logger.log("MLKIT", "Enviando imagem para ML Kit Vision...")
                recognizer.process(image)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null || event.packageName == null) return
        val pkgName = event.packageName.toString()

        if (pkgName.contains("uber") || pkgName.contains("99")) {
            if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED ||
                event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED) {
                
                triggerCaptureLogic(pkgName)
            }
        }
    }

    private fun triggerCaptureLogic(pkgName: String) {
        Logger.log("MONITOR", "Gatilho de captura acionado para $pkgName")
        val now = System.currentTimeMillis()
        if (now - lastCaptureTime > CAPTURE_COOLDOWN) {
            lastCaptureTime = now
            scheduleScreenshot(DELAY_FAST, pkgName, isRetry = false)
        }
    }

    private fun scheduleScreenshot(delay: Long, pkgName: String, isRetry: Boolean) {
        mainHandler.postDelayed({
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                
                // FOR√áAR OCULTAR CARD (Fix Duplica√ß√£o)
                try { 
                    sendBroadcast(Intent("com.motoristapro.ACTION_HIDE_CARD"))
                    Thread.sleep(300) 
                } catch(e: Exception) {}

                takeScreenshot(
                    Display.DEFAULT_DISPLAY,
                    executor,
                    object : TakeScreenshotCallback {
                        override fun onSuccess(result: ScreenshotResult) {
                            try {
                                val hardwareBuffer = result.hardwareBuffer
                                val colorSpace = result.colorSpace
                                val bitmap = Bitmap.wrapHardwareBuffer(hardwareBuffer, colorSpace)
                                val copy = bitmap?.copy(Bitmap.Config.ARGB_8888, true)
                                hardwareBuffer.close()
                                
                                if (copy != null) {
                                    // APLICA FILTRO AVAN√áADO (BINARIZA√á√ÉO)
                                    val processedBitmap = preprocessAdvanced(copy)
                                    runOcr(processedBitmap, pkgName, isRetry)
                                }
                            } catch (e: Exception) {
                                Log.e("MotoristaPro", "Erro print: ${e.message}")
                            }
                        }
                        override fun onFailure(errorCode: Int) {}
                    }
                )
            }
        }, delay)
    }

    // === MELHORIA 1: VIS√ÉO DE ALTA PRECIS√ÉO ===
    private fun preprocessAdvanced(original: Bitmap): Bitmap {
        try {
            val width = original.width
            val height = original.height
            val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            val canvas = Canvas(bitmap)
            val paint = Paint()

            // 1. Detectar se √© Modo Noturno (M√©dia de brilho)
            // Se for escuro, INVERTE as cores para ficar Fundo Branco/Letra Preta (OCR prefere assim)
            var isDark = false
            // Amostragem simples no centro da imagem
            val samplePixel = original.getPixel(width / 2, height / 2)
            val lum = (0.299 * Color.red(samplePixel) + 0.587 * Color.green(samplePixel) + 0.114 * Color.blue(samplePixel)) / 255
            if (lum < 0.5) isDark = true

            // Matriz de Cor
            val colorMatrix = ColorMatrix()
            
            // Passo A: Escala de Cinza
            colorMatrix.setSaturation(0f) 

            // Passo B: Alto Contraste (Thresholding via Matriz)
            // Aumenta drasticamente o contraste para 'matar' cinzas m√©dios
            val contrast = 4.0f 
            val scale = floatArrayOf(
                contrast, 0f, 0f, 0f, -128f * contrast + 128f,
                0f, contrast, 0f, 0f, -128f * contrast + 128f,
                0f, 0f, contrast, 0f, -128f * contrast + 128f,
                0f, 0f, 0f, 1f, 0f
            )
            colorMatrix.postConcat(ColorMatrix(scale))

            // Passo C: Invers√£o (se for modo noturno)
            if (isDark) {
                val invert = floatArrayOf(
                    -1f, 0f, 0f, 0f, 255f,
                    0f, -1f, 0f, 0f, 255f,
                    0f, 0f, -1f, 0f, 255f,
                    0f, 0f, 0f, 1f, 0f
                )
                colorMatrix.postConcat(ColorMatrix(invert))
            }

            val filter = ColorMatrixColorFilter(colorMatrix)
            paint.colorFilter = filter
            canvas.drawBitmap(original, 0f, 0f, paint)

            return bitmap
        } catch (e: Exception) {
            return original // Fallback para imagem original se der erro
        }
    }

    private fun runOcr(bitmap: Bitmap, pkgName: String, isRetry: Boolean) {
        val image = InputImage.fromBitmap(bitmap, 0)
        val screenHeight = bitmap.height

        Logger.log("MLKIT", "Enviando imagem para ML Kit Vision...")
        recognizer.process(image)
            .addOnSuccessListener { visionText ->
                val jsonArray = JSONArray()
                
                for (block in visionText.textBlocks) {
                    for (line in block.lines) {
                        val bbox = line.boundingBox
                        if (bbox != null) {
                            val obj = JSONObject()
                            obj.put("text", line.text)
                            obj.put("h", bbox.height())
                            obj.put("y", bbox.top)
                            jsonArray.put(obj)
                        }
                    }
                }

                if (jsonArray.length() > 0) {
                    sendToOverlay(jsonArray.toString(), pkgName, screenHeight)
                } else if (!isRetry) {
                    scheduleScreenshot(DELAY_RETRY - DELAY_FAST, pkgName, true)
                }
            }
    }

    private fun sendToOverlay(jsonData: String, pkg: String, screenH: Int) {
        val intent = Intent("ACTION_PROCESS_TEXT")
        intent.putExtra("JSON_DATA", jsonData)
        intent.putExtra("APP_PACKAGE", pkg)
        intent.putExtra("SCREEN_HEIGHT", screenH)
        intent.setPackage(packageName)
        sendBroadcast(intent)
    }

    override fun onInterrupt() {}
    override fun onDestroy() { super.onDestroy(); executor.shutdown() }
}
